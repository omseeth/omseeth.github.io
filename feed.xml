<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://omseeth.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://omseeth.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-09-29T18:25:59+00:00</updated><id>https://omseeth.github.io/feed.xml</id><title type="html">blank</title><subtitle></subtitle><entry><title type="html">Transformer-Modelle wie GPT und BERT erklärt (German version)</title><link href="https://omseeth.github.io/blog/2024/transformer/" rel="alternate" type="text/html" title="Transformer-Modelle wie GPT und BERT erklärt (German version)"/><published>2024-09-13T16:40:16+00:00</published><updated>2024-09-13T16:40:16+00:00</updated><id>https://omseeth.github.io/blog/2024/transformer</id><content type="html" xml:base="https://omseeth.github.io/blog/2024/transformer/"><![CDATA[<p>Um die theoretische Grundlage zum Verständnis eines BERT-Modells zu schaffen, umreiße ich in diesem Blogbeitrag einige Konzepte der Transformerarchitektur. Dazu diskutiere ich in <strong>1</strong> <em>feedforward</em> neuronale Netze. In Abschnitt <strong>2</strong> beschreibe ich rekurrente neuronale Netze mit einer Enkodierer-Dekodierer-Architektur und dem ersten Aufmerksamkeitsmechanismus. In <strong>3</strong> führe ich alle Elemente zusammen, um ein Transformer-Modell zu beschreiben. Abschließend gehe ich in <strong>4</strong> auf die Besonderheiten der GPT-Modelle und BERTs ein und führe das Konzept des Transferlernens ein.</p> <p>Dieser Beitrag verfolgt zwei Ziele. Zum einen sollen Transformer-Modelle über ihre historische Genese erklärt werden, deshalb empfehle ich die Abschnitte <strong>1</strong> und <strong>2</strong> nachzuvollziehen, wobei das Augenmerk hier auf der Verarbeitung von Sequenzen mit einer Enkodierer-Dekodierer-Struktur liegen sollte. Zum anderen liegt den Transformer-Modellen ein ‘neuer’ (d.h. für das Jahr 2017 neuer) Selbstaufmerksamkeitsmechanismus zugrunde, bei welchem sich auch ein mathematisches Verständnis lohnt. Einmal mehr wird es hoffentlich für die Leserschaft nicht schwierig sein, diesen zu verstehen, sobald ein Gespür für vorangegangene Aufmerksamkeitsmechanismen da ist.</p> <p>Dieser Blogeintrag soll eine Hilfe sein, um Transformer-Modell zu verstehen. Nichtsdestotrotz empfehle ich die zitierten Veröffentlichungen ebenfalls zu lesen. Eine chronologische Lektüre ist dazu sinnvoll.</p> <h2 id="1-feedforward-neuronale-netze">1 <em>Feedforward</em> neuronale Netze</h2> <h4 id="11-definition-eines-neuronalen-netzes">1.1 Definition eines neuronalen Netzes</h4> <p>Abstrakt betrachtet ist ein neuronales Netz zunächst ein Ansatz, um eine Funktion \(f(X; \theta)\) zu approximieren, durch die mit den Parametern \(\theta\) die Eingabewerte \(X\) abgebildet werden können (Goodfellow et al. 2016). Als Klassifikator würde ein Netz zum Beispiel mit den richtigen Parametern \(f(x)=y\) vorhersagen, wobei \(y\) einem Klassenlabel entspricht (Goodfellow et al. 2016).</p> <p>Neuronale Netze bestehen aus einer Mehrzahl von verknüpften Funktionen, die mit Hilfe eines gerichteten kreisfreien Graphen eine Eingabe bis zur Ausgabe verarbeiten. Die jeweiligen Funktionen können auch als Schichten (<em>layers</em>) \(h_{i}\) mit \(i \in N\) und \(N\) als entsprechende Tiefe des Netzes bezeichnet werden. Die letzte Schicht wird als Ausgabeschicht \(a\) bezeichnet. Anstatt dass man jede Funktion einer Schicht als eine Abbildung eines Vektor auf einen Vektor betrachtet, sollte man die Funktionen eher als weitere Kompositionen von Einheiten verstehen, die parallel Vektoren auf Skalare abbilden (Goodfellow et al. 2016). Für diese Abbildungen werden nicht-lineare Aktivierungsfunktionen genutzt. Ein neuronales Netz wird als <em>feedforward</em> bezeichnet, wenn von der Eingabe bis zur Ausgabe des Informationsflusses keine Form von Feedback berücksichtigt wird (Goodfellow et al. 2016).</p> <h4 id="12-training-eines-neuronalen-netzes">1.2 Training eines neuronalen Netzes</h4> <p>Die Approximation der Parameter \(\theta\) (damit sind die Gewichtungen und Biases des Netzes gemeint) folgt dem typischen Schema des maschinellen Lernens aus drei Schritten für jede Trainingsinstanz.</p> <ol> <li>Für \(x \in X\) sagt das Netz einen Wert \(y\) vorher.</li> <li>Dieser Wert wird mit einer weiteren Funktion, einer Kostenfunktion, ‘bewertet’. Die Kosten geben eine Information darüber ab, inwieweit sich die Vorhersage des Netzes von einem Soll-Wert unterscheidet (typische Kostenfunktionen sind z.B. <em>Mean Squared Error</em> oder <em>Binary Cross Entropy</em>). Durch den Einbezug eines Zielwertes (manchmal auch als <em>Ground Truth</em> bezeichnet) kann hier auch vom überwachten Lernen gesprochen werden.</li> <li>Um zukünftige Kosten zu senken, werden mit einem Optimierungsalgorithmus alle Parameter des Netzes mit Hinblick auf die Kostenfunktion angepasst. Dieser Algorithmus versucht die Kostenfunktion zu minimieren, indem das globale Minimum der Funktion durch Anpassung der Modellparameter in Bezug auf die Kostenfunktion für eine Eingabe angenähert wird. Der letzte Schritt involviert in den klassischen Verfahren das Berechnen der Gradienten der Parameter, mit denen das Modell für die nächste Lernrunde entsprechend der Steigung verändert werden kann (z.B. mit dem <em>Gradient-Descent</em>-Algorithmus). In einem mehrschichtigen neuronalen Netz müssen dafür partielle Ableitungen für alle Parameter der verketteten Funktionen gefunden werden. Die Berechnung kann mit dem <em>Backpropagation</em>-Verfahren durchgeführt werden, das rekursiv die Kettenregel innerhalb eines Berechnungsgraphen ausführt und so die Ableitungen aller Gradienten findet.</li> </ol> <h2 id="2-rekurrente-netze-mit-einer-enkodierer-dekodierer-architektur">2 Rekurrente Netze mit einer Enkodierer-Dekodierer-Architektur</h2> <h4 id="21-definition-eines-rekurrenten-neuronalen-netzes">2.1 Definition eines rekurrenten neuronalen Netzes</h4> <p>Im Unterschied zu den <em>feedforward</em> Netzen werden bei rekurrenten neuronalen Netzen Informationen innerhalb einer Schicht mit den Zuständen \(h_{i}^{t}\) (auch <em>hidden states</em> bzw. verborgene Zustände genannt) ausgetauscht. Jeder Zustand zum Zeitpunkt \(t\) erhält nicht nur Informationen aus der Eingabe, sondern auch aus den Zuständen \(t-1\), also aus \(h_{i}^{t-1}\) (vgl. <strong>Fig. 1</strong>). Die Rekurrenz kann dabei prinzipiell ebenfalls von der Ausgabe zu jeder Zwischenschicht oder nur bei jeder Ausgabe vorgenommen werden.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/rnn-480.webp 480w,/assets/img/rnn-800.webp 800w,/assets/img/rnn-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/rnn.png" class="img-fluid mx-auto d-block" width="40%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Fig. 1:</strong> Status eines neuronalen Netzes ohne (<em>feedforward</em>) und mit Feed-back (rekurrent) sowie jeweils einer Eingabeschicht \(x\), einer verborgenen Schicht \(h1\) und einer Ausgabe \(a\)</p> <p>Der Vorteil rekurrenter neuronaler Netze wie dem <em>Long Short-Term Memory</em>-Modell (kurz LSTM in Hochreiter und Schmidhuber, 1997) liegt darin, insbesondere sequenzielle Daten wie zum Beispiel Sprache sehr gut modellieren zu können. Wie man mit Ferdinand de Saussure inspiriert pointieren kann: Die Bedeutung eines Wortes leitet sich aus dem Zusammenspiel der Differenzen der umliegenden Wörter ab (de Saussure, 1931). So kann auch ein neuronales Netz wenig Sinn aus einer isolierten Betrachtung eines jeden Wortes ableiten. Werden hingegen die Bedeutungen der umliegenden Worteingaben mit in einer Schicht eines rekurrenten Netzes einbezogen, das heißt insgesamt eine Sequenz, können dadurch komplexere Zusammenhänge abgebildet werden.</p> <h4 id="22-ein-auto-regressives-sprachmodell">2.2 Ein auto-regressives Sprachmodell</h4> <p>Mit diesen Werkzeugen können wir bereits ein einfaches Sprachmodell zur Vorhersage von Sequenzen entwickeln. Angenommen wir wollen ein Modell, das eine Sequenz \(w\) mit \(w=(w_{1}, w_{2}, w_{3}, ..., w_{n})\) generiert, wobei \(n\) der Länge der Wörter entspricht, die zu der Sequenz, zum Beispiel einem Satz, gehören. Ein viel genutzter Ansatz in der natürlichen Sprachverarbeitung ist, die Vorhersage jedes Wortes durch alle vorangegangen Wörter der Sequenz abzuleiten. Diese Idee können wir mit der Kettenregel für Wahrscheinlichkeiten wie folgt darstellen: \begin{equation} p(w) = p(w_{1}) \cdot p(w_{2}|w_{1}) \cdot p(w_{3}|w_{1}, w_{2}) \cdot … \cdot p(w_{n}|w_{1}, …, w_{n-1}) \end{equation} An dieser Stelle ist es bereits sinnvoll, nachzuvollziehen, dass wir hier eine auto-regressive Vorhersage der Sequenz verfolgen, bei der jedes Wort als abhängig von allen vorherigen Wörtern behandelt wird.</p> <p>Auf das maschinelle Lernen anhand der Daten \(w\) übertragen folgt aus der vorgeschlagenen Sprachmodellierung, dass wir folgende Funktion approximieren wollen: \begin{equation} p(w; \theta) \end{equation} d.h. wir suchen die besten Parameter \(\theta\) mit vielen Sprachdaten (auch Korpora genannt) für unser Modell, mit denen wir eine Vorhersage für eine Sequenz von Wörtern \(w\) erreichen können, die den genutzten Daten entspricht. Die Approximation können wir durch ein Training sowohl mit einem einfachen <em>feedforward</em> neuronalen Netz als auch einem rekurrenten realisieren. Das rekurrente hat den Vorteil, dass es mit der Weiterreichung von Informationen durch die Status innerhalb jeder seiner Schichten besser die vorangegangenen Wörter mit einbezieht.</p> <h4 id="23-enkodierer-dekodierer-modelle-zur-maschinellen-übersetzung">2.3 Enkodierer-Dekodierer-Modelle zur maschinellen Übersetzung</h4> <p>Mit LSTM-Modellen entwickeln Sutskever et al. (2014) eine Sequenz-zu-Sequenz-Architektur zur maschinellen Übersetzung. Bei ihrem Ansatz kommen zwei wichtige Ideen zusammen. Zum einen (a) soll eine Übersetzung durch die Ursprungssprache bedingt werden, d.h. ein übersetzter Satz \(A\) (Ausgabe) hängt von seinem Ursprungssatz \(E\) (Eingabe) ab. Zum anderen (b) können Übersetzungen nicht immer wortwörtlich vollzogen werden. Aus diesem Grund ist es sinnvoll, dass ein Modell den ganzen Ursprungssatz berücksichtigt, bevor es eine potentielle Übersetzung vorhersagt.</p> <p>Die erste Idee (a) führt zu den <em>bedingten</em> Sprachmodellen: \begin{equation} p(w | c; \theta) \end{equation} Bei diesen Modellen hängt die Vorhersage der Wortsequenz nicht nur von jedem vorangegangen Wort ab, sondern wird auch durch den für die Übersetzung so wichtigen Ursprungssatz \(c\) bedingt. Prinzipiell kann es sich aber auch um andere Informationen handeln, die so in die Vorhersage mit einfließen würden.</p> <p>Die zweite Idee (b) setzen Sutskever et al. (2014) um, indem sie eine Architektur aus zwei Teilen, einem Enkodierer und einem Dekodierer (siehe <strong>Fig. 2</strong>), entwickeln (vgl. auch Cho et al. 2014). Wobei der Enkodierer den Ursprungssatz in eine feste Repräsentation \(c\) zusammenfasst und dann diese dem Dekodierer zum Vorhersagen der Übersetzung in der Zielsprache übergibt.</p> <p>Für den Enkodierer nutzen Sutskever et al. (2014) ein LSTM-Modell, dem Vektorrepräsentationen (auch <em>Embeddings</em> genannt) für die Wörter einer Eingabesequenz aus der Ursprungssprache zugeführt werden. Es werden <em>Embeddings</em> aus dem einfachen Grund verwendet, da neuronale Netze nur mit Zahlen und nicht mit Buchstaben operieren können. Die verborgenen Status dieser Eingaben werden daraufhin durch das Modell zu einem finalen Zustand \(c\) zusammengeführt: \begin{equation} c = q({h^{1},…,h^{T}}) \end{equation} wobei \(q\) dem LSTM-Modell entspricht und \(T\) der Länge der Eingabesequenz. Dieser Zustand \(c\) wird dem Dekodierer übergeben.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/seq2seq_ger-480.webp 480w,/assets/img/seq2seq_ger-800.webp 800w,/assets/img/seq2seq_ger-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/seq2seq_ger.png" class="img-fluid mx-auto d-block" width="90%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Fig. 2:</strong> Sequenz-zu-Sequenz-Architektur mit Enkodierer und Dekodierer</p> <p>Der Dekodierer besteht auch aus einem LSTM-Modell, welches auf der Grundlage des übergebenen Zustandes Wort für Wort eine Übersetzung in der Zielsprache vorhersagt. Dabei werden jedes übersetzte Wort und der Enkodierer-Endzustand der ursprünglichen Eingabe \(c\) regressiv dem Dekodierer so lange zugeführt, bis das Modell die Übersetzung abschließt: \begin{equation} p(w)= \prod_{t=1}^{T}p(w_{t}|{w_{1},…,w_{t-1}},c) \end{equation} Es schließt die Übersetzung ab, sobald es den Token <strong>&lt;eos&gt;</strong> vorhersagt. Mit diesem besonderen Token zeigen wir dem Modell bereits während des Trainings, an welcher Stelle Sequenzen beginnen und enden. In seinen Prädiktionen wird das Modell deshalb auch im besten Fall am Ende einer Sequenz noch diesen Token vorhersagen und den Inferenzprozess dadurch selbst terminieren.</p> <p>Abschließend noch ein weiteres Wort zum Training eines Sequenz-zu-Sequenz-Modells: während des Trainings werden dem Enkodierer des Modells Sätze aus der Ursprungssprache und dessen Dekodierer deren Übersetzungen entsprechend eines Hyperparameters (z.B. mit <em>Professor Forcing</em> (Goyal et al., 2016)) gezeigt, wodurch die Gewichte \(\theta\) beider Kodierer stets zusammen gelernt und aufeinander abgestimmt werden können.</p> <h4 id="24-der-erste-aufmerksamkeitsmechanismus">2.4 Der erste Aufmerksamkeitsmechanismus</h4> <p>Um die Qualität der Übersetzungen, insbesondere für lange Sequenzen, zu verbessern, führen Bahdanau et al. (2014) einen Aufmerksamkeitsmechanismus ein. Die Schwäche der Architektur nach Sutskever et al. (2014) liegt darin, dass die zu übersetzende Eingabe in eine einzige Repräsentation \(c\) gezwängt wird, mit welcher der Dekodierer eine Übersetzung finden muss. Allerdings spielen für eine Übersetzung nicht alle Wörter eines Satzes eine gleich große Rolle und auch kann die Beziehung unter den Wörtern variieren. Ob der Artikel in ‘the annoying man’ für ‘l’homme ennuyeux’ mit ‘le’ oder ‘l´’ übersetzt wird, hängt im Französischen beispielsweise davon ab, ob auf den Artikel ein Vokal folgt, gegebenenfalls mit einem stummen ‘h’ davor (Bahdanau et al. 2014). Bahdanau et al. (2014) entwickeln deshalb einen Mechanismus, der diesen Nuancen besser gerecht wird (vgl. <strong>Fig. 3</strong>).</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/attention_seq-480.webp 480w,/assets/img/attention_seq-800.webp 800w,/assets/img/attention_seq-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/attention_seq.png" class="img-fluid mx-auto d-block" width="60%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Fig. 3:</strong> Aufmerksamkeitsgewichte für eine Eingabe mit Bezug auf die Ausgabe an der Position <em>i=2</em></p> <p>Die um Aufmerksamkeit erweiterte Architektur übermittelt dem Dekodierer statt \(c\) für jede Eingabe kontextabhängige Zustände \(c_{i}\): \begin{equation} c_{i} = \sum_{t=1}^{T}a_{it}h^{t} \end{equation} Das Gewicht \(a_{it}\) für jeden Zustand \(h^{t}\) (in (Bahdanau et al. 2014) auch ‘Annotation’ genannt), wird wie folgt ermittelt: \begin{equation} a_{it} = \frac{\exp(e_{it})}{\sum_{k=1}^{T}\exp(e_{ik})} \end{equation} wobei \(a_{it}\) eine Normalisierung (ähnlich der <em>Softmax</em>-Funktion) für das Anpassungsmodell \(e_{it}\) ist. Dieses Modell ist wiederum ein <em>Feedforward</em>-Netz mit einer einzelnen Schicht, das bewertet, wie gut die Eingabe zum Zeitpunkt \(t\) mit der Ausgabe an Position \(i\) übereinstimmt. Damit erhält insgesamt jede Eingabe \(x^{1}...x^{T}\) eine eigene Menge an Aufmerksamkeitsgewichten, die in \(c_{i}\) resultieren, einem Kontextvektor, der dem Dekodierer hilft für jede Eingabe die passende Ausgabe (z.B. ‘l’homme’) zu bestimmen.</p> <h2 id="3-transformer-modelle-mit-selbstaufmerksamkeit">3 Transformer-Modelle mit Selbstaufmerksamkeit</h2> <h4 id="31-die-struktur-eines-transformer-modells">3.1 Die Struktur eines Transformer-Modells</h4> <p>Die Transformerarchitektur (Vaswani et al., 2017) führt einige der zuvor genannten Elemente zusammen. Die Architektur verleiht dabei dem Aufmerksamkeitsmechanismus eine wesentlich größere Rolle und verzichtet auf rekurrente Strukturen.</p> <p>Der Enkodierer der Transformerarchitektur besteht aus Ebenen mit jeweils zwei Komponenten, durch die die eingehenden Informationen verarbeitet werden (vgl. <strong>Fig. 4</strong>). Eingaben werden als erstes einer Schicht mit einem Selbstaufmerksamkeitsmechanismus parallel zugeführt, der in Vaswani et al. (2017) vorgestellt wird. Nachdem dieser Mechanismus angewendet wurde, werden die Informationen normalisiert und daraufhin einer weiteren Schicht mit einem <em>feedforward</em> neuronalen Netz übergeben. Die Verarbeitung der Eingaben findet auf dieser Schicht wiederum einzeln statt. Für den Zwischenschritt der Normalisierung werden Mittelwerte und Standardabweichungen nach dem Prinzip der <em>Layer Normalization</em> berechnet (Ba et al. 2016). Zusätzlich wird die normalisierte Ausgabe mit der Eingabe der vorangegangenen Schicht addiert. Dies wird auch als ‘<em>Residual Connection</em>’ bezeichnet und ist eine Methode, um dem Problem verschwindender Gradienten während der <em>Backpropagation</em> etwas entgegenzuwirken.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/transformer_encoder_ger-480.webp 480w,/assets/img/transformer_encoder_ger-800.webp 800w,/assets/img/transformer_encoder_ger-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/transformer_encoder_ger.png" class="img-fluid mx-auto d-block" width="60%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Fig. 4:</strong> Enkodierer eines Transformer-Modells</p> <h4 id="32-embeddings-mit-positionaler-enkodierung">3.2 <em>Embeddings</em> mit positionaler Enkodierung</h4> <p>Wie bei den vorigen Sequenz-zu-Sequenz-Architekturen wird die Eingabe zuerst in <em>Embeddings</em> überführt. Die <em>Embeddings</em> werden aber zusätzlich mit einer Positionsenkodierung versehen, die über eine Frequenzdarstellung (Sinus- und Kosinusfunktionen) realisiert wird. Dies begründet sich wie folgt. Im Gegensatz zu den rekurrenten Ansätzen verarbeitet die Aufmerksamkeitsschicht eines Transformerkodierers eine Eingabesequenz auf einmal und zum Beispiel im Falle einer Übersetzung nicht Wort für Wort. Ohne eine zusätzliche Information zur Position einer jeden Eingabe innerhalb einer Sequenz würden den Kodierern die wichtige Information fehlen, wie die einzelnen Wörter aufeinander folgen.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/embeddings_ger-480.webp 480w,/assets/img/embeddings_ger-800.webp 800w,/assets/img/embeddings_ger-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/embeddings_ger.png" class="img-fluid mx-auto d-block" width="90%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Fig. 5:</strong> Beispielsequenz, deren Tokens in Embeddings mit \(d=4\) überführt werden</p> <p>Für die Verarbeitung der Eingabe hält die Transformerarchitektur eine <em>Embedding</em>-Matrix für alle Vokabeln der Daten bereit, die in das Training eines Tranformer-Modells einfließen. Die Größe der Matrix entspricht der Anzahl der Vokabeln (sonst als Tokens bezeichnet, zu denen auch bspw. Satzzeichen zählen) Kreuz einer gewählten Dimension (also n x d), mit der jedem Eingabetoken genau eine Zeile innerhalb der Matrix zugeordnet werden kann (vgl. <strong>Fig. 5</strong>). Die Anzahl der Spalten entsprechen der gewählten Dimension. Die Matrixwerte für die Tokentypen werden während der Initialisierung eines Transformer-Modells zufällig ausgewählt. Es sind die Zeilen dieser Matrix, die auch als <em>Embeddings</em> bezeichnet werden. Man kann auch sagen, dass jeder Tokentyp eine Vektorrepräsentation besitzt. Wobei diese Vektoren in einem weiteren Schritt mit der positionalen Enkodierung addiert so der Eingabe eine einzigartige Darstellung verleihen. Entscheidend ist, dass die <em>Embeddings</em> der Transformerarchitektur sich im Laufe eines Trainings auch verändern, d.h. entsprechend der Daten angepasst, also ‘gelernt’ werden können. (Anmerkung: der erste Schritt ist, die Eingabetokens in eine <em>One-hot</em> Enkodierung zu überführen, mit der jedem Token eine Zeile in der <em>Embedding</em>-Matrix zugeordnet werden kann.)</p> <p>Zur Veranschaulichung der Positionsenkodierung ist es hilfreich, zunächst ein stark vereinfachtes Beispiel zu betrachten. Angenommen man teilt jedem Embedding einfach die Positionen (<em>pos</em>) des jeweiligen Tokens in Form von ganzen Zahlen mit \(n \in N\), wobei \(N\) der Länge der Eingabetokens inklusive &lt;eos&gt;-Token entspricht, zu. Wenn wir den Token “heiße” und dessen <em>Embedding</em> [0.11, 0.45, 0.23, 0.77] (ausgedachte Werte) auswählen, dann ließe sich für den Token innerhalb der Sequenz “&lt;eos&gt; ich heiße max &lt;eos&gt;” auf diese Weise eine Positionsenkodierung von [2, 2, 2, 2] ermitteln. Der Positionsvektor hätte diese Werte, wenn wir für das Wort “heiße” die zweite Position der Sequenz (Sequenz beginnt bei 0) und eine <em>Embedding</em>-Dimension von \(d=4\) wählen. Der Transformer-Architektur entsprechend könnten wir diesen Vektor anschließend auf das <em>Embedding</em> des Tokens addieren [2.11, 2.45, 2.23, 2.77] und hätten diesem auf diese Weise zusätzliche Informationen hinzugefügt. Dieser Ansatz würde jedoch zu mehreren Problemen führen: Zu nennen sind hier beispielsweise große Werte für lange Sequenzen, deren Positionsenkodierung die Werte der <em>Embeddings</em> stark beeinflussen würden und kein relativer Bezug wiederkehrender Positionsmuster.</p> <p>Vaswani et al. (2017, S. 6) stellen deshalb eine Positionsenkodierung vor, durch die jedem Tokenembedding über das Bogenmaß der trigonometrischen Funktionen zusätzliche Informationen zu der Position des Tokens innerhalb einer Sequenz zugeführt werden. Die Vorteile dieses Ansatzes sind unter anderem, dass die Positionsenkodierungswerte auf ein Intervall von \([-1,1]\) beschränkt werden können, und die Periodizität der trigonometrischen Funktionen auch erlaubt, wiederkehrende Muster abzubilden. Denn bestimmte Abstände zwischen Positionen werden ähnliche Werte in den Positionskodierungen erzeugen. Dadurch kann das Modell leichter lernen, dass sich bestimmte Muster oder Abstände zwischen Tokens in unterschiedlichen Bereichen einer Sequenz wiederholen, unabhängig von der genauen Position in der Sequenz.</p> <p>Die Positionen der Tokens werden nach Vaswani et al. (2017) wie folgt berechnet: \begin{equation} PE_{(pos, 2i)} = sin(\frac{pos}{10000^{\frac{2i}{d}}}) \end{equation} \begin{equation} PE_{(pos, 2i+1)} = cos(\frac{pos}{10000^{\frac{2i}{d}}}) \end{equation} <em>pos</em> entspricht der absoluten Position innerhalb einer Eingabesequenz der Länge <strong>N</strong>, der Wert \(10000\) ist eine gewählte Konstante, und <strong>i</strong> verweist auf die Indezes der <em>Embeddings</em>, d.h. bei einer gewählten Dimension der <em>Embedding</em>-Vektoren mit \(d=4\), gilt \(i \in I= \{0, 1, 2, 3\}\). Schließlich erlauben die beiden Sinus- und Kosinusfunktionen für gerade und ungerade Indizes unterschiedliche Werte zu ermitteln. Für alle gerade Indizes eines <em>Embeddings</em> können wir (8) und für alle ungeraden (9) verwenden. Erwähnenswert ist hier, dass die Frequenzen der Sinus- und Kosinusfunktionen der <em>PE</em> von der gewählten Dimension abhängig sind. Kleine <em>Embedding</em>-Dimensionen führen zu höheren Frequenzen (feinere Positionsauflösungen) und hohe Dimensionen zu niedrigere Frequenzen (grobere Positionsauflösungen). Anhand dieser Vorgaben wird schließlich für jede Eingabe eine Positionsenkodierungs-Matrix berechnet – also für jeden Token ein Positionsvektor (vgl. <strong>Fig. 6</strong>) – welche wir daraufhin auf die Matrix der Token-<em>Embeddings</em> addieren können. Im Zusammenspiel mit den <em>Embeddings</em> wird dem Transformer-Modell dadurch eine kontextsensitive Repräsentation der Tokens zur weiteren Verarbeitung überreicht.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/positional_encoding-480.webp 480w,/assets/img/positional_encoding-800.webp 800w,/assets/img/positional_encoding-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/positional_encoding.png" class="img-fluid mx-auto d-block" width="90%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Fig. 6:</strong> Beispielsequenz, deren Tokens in Positionsenkodierungen mit \(d=4\) überführt werden</p> <h4 id="33-selbstaufmerksamkeitsmechanismus">3.3 Selbstaufmerksamkeitsmechanismus</h4> <p>Im Gegensatz zu dem Aufmerksamkeitsmechanismus nach Bahdanau et al. (2014) entwickeln Vaswani et al. (2017) einen Selbstaufmerksamkeitsmechanismus, den sie auch als ‘skalierte Skalarprodukt-Aufmerksamkeit’ beschreiben (Vaswani et al., 2017, S.3). Die für Transformer genutzte Selbstaufmerksamkeit kann vereinfacht zunächst mit der Operation aus (6) verglichen werden (Raschka et al., 2022). Wir können für einen kontextsensitiven Vektor \(z_{i}\) einer Eingabe an der Stelle \(i\) die Aufmerksamkeit wie folgt berechnen (Raschka et al., 2022): \begin{equation} z_{i} = \sum_{j=1}^{T}a_{ij}x^{j} \end{equation} wobei \(a_{ij}\) nicht mit einem Status \(h^{t}\), sondern mit den Eingaben \(x^{j}\) multipliziert wird, mit \(j\in{\{1...T\}}\) einer Eingabesequenz der Länge \(T\) (vgl. die Summe über alle \(x^{j}\) in (10)). Im Unterschied zu Bahdanau et al. (2014) ist \(a\) dabei keine Normalisierung von einfachen <em>feedforward</em> Netzen \(e_{ij}\), sondern eine <em>Softmax</em>-Normalisierung über die Skalarprodukte \(\Omega\) der Eingabe \(x^{i}\) bezogen auf alle anderen Eingaben \(x^{1}...x^{T}\) (Raschka et al., 2022): \begin{equation} a_{ij} = \frac{\exp(\omega_{ij})}{\sum_{j=1}^{T}\exp(\omega_{ij})} \end{equation} mit (Raschka et al., 2022): \begin{equation} \omega_{ij} = x^{(i)T}x^{j} \end{equation} Was wir hier gleichzeitig im Unterschied zum Aufmerksamkeitsmechanismus von Bahdanau et al. (2014) sehen, bei welchem die Aufmerksamkeit insbesondere die Ausgabe des Dekodierers (dort an Ausgabeposition <em>i</em>) mit einbezieht, ist, dass das Aufmerksamkeitsgewicht in (11) mit (12) sich auf die anderen Eingaben einer Sequenz bezieht. Eben aus diesem Grund ist es sinnvoll, von einer <em>Selbstaufmerksamkeit</em> zu sprechen.</p> <p>Zu dieser Darstellung der Aufmerksamkeit fügen Vaswani et al. (2017) eine weitere Veränderung für jede Eingabe \(x^{i}\) hinzu, und zwar wird das Gewicht \(a\) nicht mit \(x^{j}\) multipliziert, sondern mit einem Wert \(v^{j}\): \begin{equation} z_{i} = \sum_{j=1}^{T}a_{ij}v^{j} \end{equation} Denn Vaswani et al. (2017) überführen jedes \(x\) in ein Tripel aus (\(v^{i}\), \(k^{i}\), \(q^{i}\)) mittels den Projektionsmatrizen (\(V\), \(K\), \(Q\) – die hier auch als zusätzliche lineare Schichten aufgefasst werden können). Die Idee dahinter entstammt dem <em>Information Retrieval</em>, das mit Wert-, Schlüssel-, Abfragetripeln arbeitet (wegen Values, Keys, Queries die Abkürzungen V, K, Q). Die Skalarprodukte des Selbstaufmerksamkeitsmechanismus für jede Eingabe werden deshalb in Vaswani et al. (2017) auch nicht mit (12) berechnet, sondern mit den Abfrage- und Schlüsselwerten (Raschka et al., 2022): \begin{equation} \omega_{ij} = q^{(i)T}k^{j} \end{equation} Kurz: Neben der Aufmerksamkeit einer Eingabe \(x^i\) gegenüber allen anderen Eingaben innerhalb einer Sequenz \(X\) wird die Selbstaufmerksamkeit noch durch verschiedene Darstellungen aller umliegenden \(x^j \in X\) in Form der Abfrage-, Schlüssel-, Wertrepräsentationen berechnet.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/projection_matrices_ger-480.webp 480w,/assets/img/projection_matrices_ger-800.webp 800w,/assets/img/projection_matrices_ger-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/projection_matrices_ger.png" class="img-fluid mx-auto d-block" width="60%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Fig. 8:</strong> Aufmerksamkeit für eine Eingabe X mit mehreren Köpfen (<em>heads</em>)</p> <p>Die Aufmerksamkeitsgewichte werden abschließend mit der Dimension der <em>Embeddings</em> noch skaliert (\(\frac{\omega_{ij}}{\sqrt{d}}\)) und können \(h\)-Mal parallel berechnet, wobei \(h\) einer gewählten Anzahl an Köpfen (auch <em>Attention Heads</em> gennant) entspricht. Vaswani et al. (2017) wählen \(h=8\) Köpfe, deren Werte konkateniert abschließend der <em>Layer</em>-Normalisierung in den Kodierern weitergereicht werden (siehe <strong>Fig. 8</strong> und <strong>Fig. 4</strong>). Die Verwendung mehrerer Köpfe wird als ‘<em>Multi-head Attention</em>’ bezeichnet. Die zusätzliche Skalierung begründen Vaswani et al. (2017, S. 4) mit der Beobachtung, dass zu große Werte der Skalarprodukte (vgl. (12)) die für die Normalisierung genutzte <em>Softmax</em>-Funktion in einen Bereich führen, der beim Lernen in sehr kleine Gradienten resultiert.</p> <h4 id="34-der-transformer-dekodierer">3.4 Der Transformer-Dekodierer</h4> <p>Der Dekodierer der Transformerarchitektur folgt strukturell dem Enkodierer. Er enthält jedoch noch eine zusätzliche Schicht (vgl. <strong>Fig. 7</strong>). In dieser Schicht werden die ausgegebenen Informationen des Enkodierers (z.B. der enkodierte Ursprungssatz einer Übersetzung) über die Wert- und Schlüsselmatrizen \(V\), \(K\) mit berücksichtigt. Die Abfragewerte \(Q\) kommen hingegen von der vorangegangenen Aufmerksamkeitsschicht des Dekodierers. Durch die Kombination der Informationen sowohl des Enkodierers als auch des Dekodierers wird diese weitere Schicht auch als ‘Cross-Aufmerksamkeitsschicht’ bezeichnet. Da dabei Enkodierer-Informationen mit einbezogen werden, lässt sich bei dem ganzen Modell (Enkodierer + Dekodierer) zudem von einem <em>bedingten</em> Srpachmodell sprechen, wie dieses zuvor in (3) vorgestellt.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/transformer_decoder_ger-480.webp 480w,/assets/img/transformer_decoder_ger-800.webp 800w,/assets/img/transformer_decoder_ger-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/transformer_decoder_ger.png" class="img-fluid mx-auto d-block" width="70%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Fig. 7:</strong> Dekodierer eines Transformer-Modells</p> <p>Die Selbstaufmerksamkeitsschicht des Dekodierers erlaubt es, Teile der Dekodierereingabe zu verdecken (dies wird auch als <em>Masking</em> beschrieben, geanuer gesagt <em>Causal Masking</em>). Ein Transformer-Enkodierer lässt hingegen grundsätzlich eine Betrachtung aller Eingaben gleichzeitig zu. Das Masking spielt eine wichtige Rolle bei dem Ziel des Dekodierers: z.B. die Vorhersage einer Übersetzung. Zur Prädiktion einer Übersetzungssequenz arbeitet der Dekodierer sich jeweils autoregressiv von Token zu Token vor (z.B. von links nach rechts, vgl. hierzu auch (5)). Das bedeutet, dass beim Inferenzieren jede Prädiktion nur mit Hilfe vorangegangener Tokens arbeitet, die anderen bleiben im übertragenen Sinne maskiert. Für das Training können dem Modell noch durch <em>Teacher-Forcing</em> korrekte Übersetzungen als Eingabe mit zugeführt werden, um eine Fehlerfortpflanzung zu minimieren – wie bei den zuvor beschriebenen Sequenz-zu-Sequenz-Modellen. Grundsätzlich ist das Trainingsziel die Vorhersagen des Modells anhand der Übersetzungslösungen zu optimieren. Ein Übersetzungsprozess terminiert in jedem Fall, wenn der Token <strong>&lt;eos&gt;</strong> oder die zuvor definierte maximale Sequenzlänge erreicht sind.</p> <p>Abschließend noch ein Wort zu der linearen Schicht am Endes des Dekodierers (vgl. <strong>Fig. 7</strong>). Die unmittelbare Ausgabe aus den Aufmerksamkeitsblöcken umfasst eine durch das Modell angereicherte Repräsentation der Eingabe-<em>Embeddings</em> \(h_{i}\). In diese Repräsentation sind durch die Aufmerksamkeitsmechanismen und den <em>feedforward</em>-neuronalen Netzen zusätzliche Informationen umliegender Tokens sowie des Enkodierers mit eingeflossen. Es gilt jedes \(h_{i}\) wieder in eine Darstellung des Vokabulars zu überführen. Dafür stellt die lineare Schicht eine Projektionsmatrix \(W\) bereit. Angenommen dem Modell liegt eine Vokabelgröße von \(10 000\) zugrunde und für die <em>Embeddings</em> bzw. die Status des Modells wählen wir exemplarisch eine Dimension von \(d=512\). Dann können wir mit \(W\) (10000 x 512) alle \(h_{i}\) in einen <em>Logits</em>-Vektor überführen, der der Dimension des Vokabulars entspricht, und dessen Wert gleichzeitig die Approximation des Modells dafür ist, wie wahrscheinlich welcher der Token des Vokabulars ist: \begin{equation} logits = W \cdot h_{i} + b \end{equation} wobei \(b\) noch ein zusätzlicher Bias ist. Auf der Grundlage dieses <em>Logits</em>-Vektor (z.B. \(logits = [3.4, -1.2, 0.5, ..., 2.7]\)) kann schlussendlich die <em>Softmax</em>-Aktivierung, mit der die Werte des Vektors in Wahrscheinlichkeiten überführt werden, den wahrscheinlichsten Token für den ausgegebenen Status \(h_{i}\) des Dekodierers vorhersagen. An dieser Stelle ließen sich aber auch andere Dekodierungsstrategien (z.B. <em>Beam-Search</em> oder <em>Greedy Decoding</em>) einsetzen.</p> <h2 id="4-gpt-bert-und-co">4 GPT, BERT und co</h2> <p>Derweil die ursprüngliche Transformerarchitektur zur maschinellen Übersetzung entwickelt wurde, haben sich Transformer-Modelle bei anderen Aufgaben ebenfalls bewährt. Am bekanntesten sind große Sprachmodelle wie <em>Generative Pre-trained Transformer</em>-Modelle (Radford et al., 2018) von OpenAI, die unter der Bedingung einer Eingabe mit einem Transformer-Dekodierer den nächsten <em>Token</em> einer Sequenz vorhersagen. Das <em>Bidirectional Encoder Representations from Transformers</em>-Modell (kurz BERT, Devlin et al., 2019) ist wiederum ein Transformer-Enkodierer. Das heißt mit BERT können keine neuen Wörter oder Sätze in einer Zielsprache <em>autoregressiv</em> generiert werden. BERT stellt dafür Enkodierungen bereit, mit deren Hilfe sich zum Beispiel Klassifikationsaufgaben lösen lassen.</p> <h4 id="41-das-bidirectional-encoder-representations-from-transformers-modell">4.1 Das <em>Bidirectional Encoder Representations from Transformers</em>-Modell</h4> <p>Für BERT trainieren Devlin et al. (2019) zunächst den Enkodierer eines Transformer-Modells vor dem Hintergrund zweier Aufgaben. Die erste Aufgabe des BERT-Trainings besteht aus einer maskierten Sprachmodellierung (<em>Masked Language Modelling</em>). Das Modell bekommt dabei Sätze gezeigt, bei denen es 15% zufällig ausgewählte Wörter, die verdeckt werden, vorhersagen muss. Die zweite Aufgabe besteht aus einer binären Klassifikation zweier Sätze und zwar mit dem Ziel vorherzusagen, ob diese aufeinander folgen oder nicht. Wobei das Modell 50% korrekte Satzfolgen und 50% inkorrekte Folgen gezeigt bekommt. Da das Modell ausschließlich einen Enkodierer verwendet und keine ‘rechtsbündige’ Maskierung der jeweils nächsten Tokens innerhalb einer Sequenz wie bei einem Transformer-Dekodierer vorgenommen wird, kann das Training auch als bi-direktional bezeichnet werden. Devlin et al. (2019) nennen das Training ihres Enkodierers auf den beiden Aufgaben außerdem als ‘Vortraining’.</p> <p>In einem weiteren Schritt nutzen Devlin et al. (2019) ihr vortrainiertes BERT-Modell für weitere Experimente aus der natürlichen Sprachverarbeitung. Dafür feintunen sie BERT beispielsweise, um die plausibelste Wortfolge für Sätze aus dem Datensatz <em>Situations With Adversarial Generations</em> (Zellers et al., 2018) vorherzusagen. Da BERT ursprünglich vor dem Hintergrund bestimmter Aufgaben trainiert wurde, die Gewichte des Modells jedoch auch für neue Aufgaben verwendet und angepasst werden können, kann eine solche Verwendung BERTs auch als eine Form des Transferlernens bezeichnet werden.</p> <h2 id="zusätzliche-ressourcen">Zusätzliche Ressourcen</h2> <ul> <li>Ich kann Brendan Bycrofts Visualisierung von Transformer-Modellen empfehlen: <a href="https://bbycroft.net/llm">https://bbycroft.net/llm</a></li> <li>Mit die besten Erklärungen und Visualisierungen zu verschiedenen Modellierungsansätzen in NLP, einschließlich der Transformer-Architektur, stellt Lena Voita bereit: <a href="https://lena-voita.github.io/nlp_course.html">https://lena-voita.github.io/nlp_course.html</a></li> <li>Weitere hilfreiche Visualisierungen zu BERT gibt Jay Alammar: <a href="https://jalammar.github.io/illustrated-bert/">https://jalammar.github.io/illustrated-bert/</a></li> </ul> <h2 id="bibliographie">Bibliographie</h2> <p>Ba, J., Kiros, J.R., &amp; Hinton, G.E. (2016). Layer Normalization. ArXiv, abs/1607.06450.</p> <p>Bahdanau, D., Cho, K., und Bengio, Y. (2014). Neural Machine Translation by Jointly Learning to Align and Translate. <em>CoRR</em>, abs/1409.0473.</p> <p>Cho, K., van Merri ̈enboer, B., Gulcehre, C., Bahdanau, D., Bougares, F., Schwenk, H., und Bengio, Y. (2014). Learning Phrase Representations using RNN Encoder–Decoder for Statistical Machine Translation. In Moschitti, A., Pang, B., und Daelemans, W., Herausgeber, <em>Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)</em>, Seiten 1724–1734, Doha, Qatar. Association for Computational Linguistics.</p> <p>de Saussure, F. (1931). <em>Cours de Linguistique Generale</em>. Payot, Paris.</p> <p>Devlin, J., Chang, M.-W., Lee, K., und Toutanova, K. (2019). BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding. In Burstein, J., Doran, C., und Solorio, T., Herausgeber, <em>Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</em>, Volume 1 (Long and Short Papers), Seiten 4171–4186, Minneapolis, Minnesota. Association for Computational Linguistics.</p> <p>Goodfellow, I., Bengio, Y., und Courville, A. (2016). <em>Deep Learning</em>. MIT Press.</p> <p>Goyal, A., Lamb, A. M., Zhang, Y., Zhang, S., Courville, A. C., und Bengio, Y. (2016). Professor Forcing: A New Algorithm for Training Recurrent Networks. In Lee, D., Sugiyama, M., Luxburg, U., Guyon, I., und Garnett, R., Herausgeber, Advances in <em>Neural Information Processing Systems</em>, Band 29. Curran Associates, Inc.</p> <p>Hochreiter, S. und Schmidhuber, J. (1997). Long Short-Term Memory. <em>Neural Comput.</em>, 9(8):1735–1780.</p> <p>Radford, A., Narasimhan, K., Salimans, T., und Sutskever, I. (2018). Improving Language Understanding by Generative Pre-Training. Technical report, OpenAI.</p> <p>Raschka, S., Liu, Y., und Mirjalili, V. (2022). <em>Machine Learning with PyTorch and Scikit-Learn: Develop machine learning and deep learning models with Python</em>. Packt Publishing.</p> <p>Sutskever, I., Vinyals, O., und Le, Q. V. (2014). Sequence to sequence learning with neural networks. In <em>Proceedings of the 27th International Conference on Neural Information Processing Systems - Volume 2</em>, NIPS’14, Seite 3104–3112, Cambridge, MA, USA. MIT Press.</p> <p>Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., Kaiser, L. u., und Polosukhin, I. (2017). Attention is All you Need. In Guyon, I., Luxburg, U. V., Bengio, S., Wallach, H., Fergus, R., Vishwanathan, S., und Garnett, R., Herausgeber, <em>Advances in Neural Information Processing Systems</em>, Band 30. Curran Associates, Inc.</p> <p>Zellers, R., Bisk, Y., Schwartz, R., und Choi, Y. (2018). SWAG: A Large-Scale Ad- versarial Dataset for Grounded Commonsense Inference. In Riloff, E., Chiang, D., Hockenmaier, J., und Tsujii, J., Herausgeber, <em>Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing</em>, Seiten 93–104, Brussels, Bel- gium. Association for Computational Linguistics.</p> <p><strong>Version 0.2</strong></p>]]></content><author><name></name></author><category term="machine"/><category term="learning,"/><category term="neural"/><category term="nets,"/><category term="feed-forward,"/><category term="attention-mechanism,"/><category term="transformer,"/><category term="GPT,"/><category term="BERT,"/><category term="transfer-learning,"/><category term="German"/><summary type="html"><![CDATA[Vom neuronalen Netz bis zu GPT und BERT, eine kontextualisierte Erklärung der Transformer-Architektur]]></summary></entry></feed>